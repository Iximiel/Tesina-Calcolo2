\section{Il programma}
Per semplicit\`a e alleggerire i calcoli ho impostato $\hbar=1$, 
Gli eseguibili compilabili dal Makefile sono i seguenti, nei commenti \`e spiegato come eseguirli:
\lstinputlisting[language=make, firstline = 16, lastline = 43,frame = single]{../Makefile}

Il programma pi\`u semplice (\lstinline|$> make single|) \`e composto da un blocco \textit{impostazioni} che carica i file con le informazioni sulla simulazione, crea la trimatrice e le condizioni iniziali ,e un blocco \textit{CrankSolver} che si occupa di svolgere risolvere il sistema passo per passo (nel nostro caso non avendo potenziali che dipendono dal tempo la riduzione della trimatrice viene fatta solo una volta, nella costruzione del \textit{CrankSolver}).
Ho scelto di impostare il \textit{CrankSolver} in modo che contenga solo i punti del passo attuale perch\'e l'elevato numero di punti rischia di intasare la memoria del sistema piuttosto in fretta: i punti calcolati vengono salvati su un file in una cartella ''./results'' che deve essere creata prima di lanciare l'eseguibile, il numero di punti e la frequenza di essi viene deciso nei file di impostazione.

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}[mindmap, concept color = orange!50,every node/.style = {concept}]
\node (main){main}
	child[concept color = orange,grow = 180]{node(impostazioni){Impostazioni}
	child[concept color = red, grow = 200]{node {file\\potenziale}}
	child[concept color = red, grow = 20]{node (pot){Potenziale}
		child[concept color = yellow, grow = right, level 2 concept]{node(tridiag){matrice\\tridiagonale}}}
	child[concept color = blue!75, grow = 140]{node {file\\onda}}
	child[concept color = blue!75, grow = -20]{node (CC){CC}}
	child[concept color = blue!75, grow = -60]{node (CI){CI}}
	child[concept color = green, grow = 240]{node {file\\settings}}
	child[concept color = green, grow = 60]{node (con){passi e \\costanti}
		child[concept color = green, grow = right] {node(eta){$\eta$}}}
}
	child[concept color = orange,grow =05] {node (Solver) {CrankSolver}}
	child[concept color = red!50,grow = down]{node(out){output}};
	\path(tridiag) to[circle connection bar switch color = from (yellow) to (green)](eta);
	\path(tridiag) to[circle connection bar switch color = from (yellow) to (orange)](Solver);
	\path(tridiag) to[circle connection bar switch color = from (yellow) to (blue!75)](CC);
	\path(Solver) to[circle connection bar switch color = from (orange) to (blue!75)](CI);
	\path(Solver) to[circle connection bar switch color = from (orange) to (red!50)](out);
	\end{tikzpicture}
	\caption{Collegamenti tra i blocchi del programma}
\end{figure}

\subsection{Impostazioni}
Il programma pi\`u semplice, compilabile con \lstinline|$> make single| carica i dati da tre file di impostazioni, in cui viene alternata una riga di commento, anticipata da un ''\textit{\#}'' e una con i valori dell'impostazione, l'ordine \`e importante e il commento non deve contenere spazi.

Il file generale delle impostazioni:
\lstinputlisting[frame = single,caption=Impostazioni principali]{../settings.set}\label{lst:settings}
In questo file fornisco i parametri principali della simulazione, quelli che ho previsto che avrei cambiato pi\`u di rado durante la simulazione. La massa, la lunghezza sono ovvi, tmax \`e il tempo a cui si ferma la simulazione. L'opzione ''\textit{\#Ndipende\_da\_intervallo=0}'' se impostata uguale a $0$ fa si` che il numero di passi (spaziali e temporali) venga calcolato conoscendo la lunghezza totale e il passo, se impostata diversa da $0$ invece fa s\`i che il programma calcoli il passo a partire dalla lunghezza totale e il numero di punti voluti. Le opzioni ''\textit{\#timeskip}'' e ''\textit{\#spaceskip}'' servono nel momento di salvare i risultati: il primo imposta ogni quanti passi temporali esportare il vettore di punti, che vengono salvati ad intervalli decisi dal secondo parametro. Il parametro ''\textit{\#precisione}'' invece blocca la simulazione prima del tempo massimo se l'errore (vedi \autoref{sec:errore}) supera il valore impostato, se lo si imposta a 0 salta il controllo.

Il file delle condizioni iniziali:
\lstinputlisting[frame = single,caption=Impostazioni CI]{../gauss.set}
Il primo parametro deve essere una lettera e serve a indicare al programma la forma del pacchetto d'onda nelle condizioni iniziali, se viene scritto ''\textit{b}'' il programma disegner\`a la funzione ''bump'' con parametri presi dalla riga successiva, nell'ordine ''altezza del massimo'', ''larghezza'' e ''punto del massimo''; negli altri casi una gaussiana con i parametri ''altezza'', ''deviazione standard'' e ''punto medio''. I due set successivi alle impostazioni dell'onda riguardano le condizioni al contorno, la prima che pu\`o essere $0$, $1$ o $2$ indica il tipo di condizione, rispettivamente Dirichlet, Neumann o Robin sulla stessa riga il primo numero indica il valore della funzione, della derivata o della combinazione lineare, il terzo parametro viene solo utilizzata da Robin ed \`e il peso della funzione.
L'ultima impostazione \`e l'energia che si vuole impostare per l'onda.

Il file del potenziale:
\lstinputlisting[frame = single,caption=Impostazioni potenziale]{../potenziale.set}
Il primo parametro imposta la forma del potenziale, che pu\`o essere una gaussiana, un ''bump'', un rettagolo oppure un salto.
Nella riga successiva il primo parametro imposta l'altezza  del punto pi\`u alto del potenziale, se messo a 0 dice all'algoritmo di calcolare l'evoluzione in assenza di potenziale, il secondo parametro indica il centro della funzione se \`e pari, oppure la posizione del salto, l'ultimo parametro indica la larghezza o la deviazione standard del potenziale non viene utilizzato se la forma \`e il salto.
\subsection{Lancio senza potenziale: errore}\label{sec:errore}
Prima di tutto voglio effettuare qualche simulazione senza potenziale per poter osservare come si comporta l'onda.

Ho bisogno di definire un ''errore'' per capire quanto la simulazione possa essere andata a buon fine:
la mia scelta \`e stata di utilizzare la norma della funzione, ricordando che le funzioni d'onda sono $L^2$ e quindi la loro norma \`e  $\lr||f^2=\int_X\lr||f^2d\mu$, utilizzando la definizione dell'integrale discreto di Simpson, il che mi limita a poter fare solo simulazioni con un numero di passi pari (e in particolare multipli di 4 per aver un integrale preciso anche quando calcolo l'integrale solo nella prima o seconda met\`a del dominio) nello spazio.

Nella simulazione blocco il calcolo se la norma della funzione si discosta troppo dalla norma delle condizioni iniziali.

Per capire come impostare le simulazioni ho effettuato diversi lanci con varie combinazioni di passo temporale e passo spaziale. Riporto i vari grafici degli errori.
Da questi lanci capisco che devo scartare l'idea di usare un passo temporale grande in quanto ho notato che le funzioni d'onda vengono ''rallentate'', come si pu\`o vedere in \autoref{fig:velocita}. Dalle figure noto che le simulazioni devono avere come massimo passo temporale $0.01$. Il punto in cui gli andamenti perdono l'andamento lineare e` dovuto al fatto che il pacchetto sta impattando contro il bordo del dominio e quindi inizia a rimbalzare.

Dato che ho simulato onde con una energia di $10 udm$ mi aspetto che la velocit\`a sia:.....%%%%%

\begin{figure}[ht]
	\centering
\begin{subfigure}[b]{0.49\textwidth}
\includegraphics[width=\textwidth]{IMG/v_g1_0001}
\caption[Differenze in 0.001]{Le differenze per $dS = 0.001$}
\end{subfigure}
~
\begin{subfigure}[b]{0.49\textwidth}
\includegraphics[width=\textwidth]{IMG/v_g1_001}
\caption[Differenze in 0.01]{Le differenze per $dS = 0.01$}
\end{subfigure}

\begin{subfigure}[b]{0.5\textwidth}
\includegraphics[width=\textwidth]{IMG/v_g1_01}
\caption[Differenze in 0.1]{Le differenze per $dS = 0.1$}
\end{subfigure}
\caption{Le posizioni dei massimi nel tempo della simulazione a vari passi temporali  e spaziali}\label{fig:velocita}
\end{figure}

Poi ho quindi guardato l'errore di alcune simulazioni. Scarto a priori i passi pi\`u grandi di $0.01$.

\begin{figure}[ht]
\centering
\begin{subfigure}[b]{0.49\textwidth}
\includegraphics[width=\linewidth]{IMG/e_g1full}
\caption[Errori completo]{Il grafico completo degli errori, si vede anche quanto la riflessione influsisca sul modulo della funzione}\label{fig:fullErr}
\end{subfigure}
~
\begin{subfigure}[b]{0.49\textwidth}
	\includegraphics[width=\linewidth]{IMG/e_g1res}
	\caption[Errori zoom]{Il grafico completo degli errori uno zoom sugli andamenti non influenzati dalla riflessione}\label{fig:fullErrzoom}
\end{subfigure}
\end{figure}

A questo punto ho fatto una simulazione diminuendo il tempo a $6$ in modo da non avere a che fare con l'esplosione dell'errore dovuta al limite del dominio. e cosi` da poter osservare quale fosse il miglior passo spaziale. Ho fatto i lanci con due diverse condizioni al contorno (gaussiano con $\sigma$ $1$ e $2$). 

\begin{figure}[ht]
	\centering
	\begin{subfigure}[b]{0.49\textwidth}
		\includegraphics[width=\textwidth]{IMG/eChoosy1}
		\caption{CI: gaussiana($\sigma=2$)}
	\end{subfigure}
	~
	\begin{subfigure}[b]{0.49\textwidth}
		\includegraphics[width=\textwidth]{IMG/eChoosy2}
		\caption{CI: gaussiana($\sigma=2$)}
	\end{subfigure}
	\caption{I passi che mi se,bravano pi\`u opportuni a confronto}\label{fig:SceltaErrori}
\end{figure}

Osservando \autoref{fig:SceltaErrori} utilizzare come passi spaziali e temporali valori compresi tra $0.01$ e $0.001$ ha un buon rapporto errore(il cui modulo \`e inferiore a $10^-7$)/peso sul calcolatore, in particolare si nota che il passo spaziale pesa di pi\`u sull'errore. Ho scelto di continuare con $dT = 0.01$ e $dS = 0.005$ in quanto hanno errore molto simile a $dS = 0.001$ (\autopageref{fig:sceltaPassi}) ma sono pi\`u rapidi nei calcoli (sulla mia macchina).

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\textwidth]{IMG/sceltaPassi}
\caption[Scelta Passi]{Gli errori dei passi che ritengo pi\`u convenienti}\label{fig:sceltaPassi}
\end{figure}

\subsection{Condizioni al contorno}
Quello che io voglio simulare \`e un pacchetto d'onda che sia partito da $-\infty$ e arrivi nel ''punto interessante'', che \`e l'area che osservo nella simulazione e poi prosegua fino all'infinito (o venga eventualmente riflesso).

Per quanto riguarda le condizioni al contorno ho avuto idee:
\begin{itemize}
	\item Non tengo conto delle condizioni al contorno, faccio in modo di usare pacchetti d'onda ristretti e blocco la simulazione quando questa va ad  avvicinarsi troppo ai bordi.
	\item Uso una forma d'onda tale per cui conosco la funzione e la sua derivata in ogni punto
	\item Emulo un ambiente chiuso (con ai lati muri di potenziale alti $\infty$)
\end{itemize}
La prima ipotesi \`e stata quella che ho usato in tutte le prove che ho effettuato prima di iniziare a raccogliere dati.

Per la seconda ipotesi dovrei usare come condizione iniziale una funzione e calcolarne la derivata per ogni passo negli estremi a priori il discorso non si applica ma i pacccheti d'onda hanno una dispersione tendono ad allargarsi, per cui se  per esempio avessi un pacchetto d'onda generico ($\Psi(x,t) = e^{ikx} \psi(x,t)$)la relazione dovrebbe essere $\partial_x \Psi(x,t) = ik \Psi(x,t) + e^{ikx}\partial_x\psi(x,t)$ e potrei quindi utilizzare le CC di Robin in caso conoscessi come la funzione si disperde nel tempo potrei ricalcolare ad ogni passo le condizioni al contorno ed applicarle. Questo per\`o mi porterebbe a svariati problemi quali l'incertezza che la simulazione e la teoria siano esattamente parallele sulla dispersione 

La terza idea equivale a utilizzare Dirichlet con il valore della funzione pari a 0 nei bordi. In pratica assomiglia alla mia prima idea, specie se blocco la simulazione prima dell'impatto

%Per cui ho deciso di ricercare un'idea che simulasse l'assenza di vincoli: ho trovato le cosiddette condizioni al contorno trasparenti.
%Ma ho lasciato perdere data la loro complessit\`a e il poco tempo a mia disposizione, in quanto utilizza la trasformazione Z
\subsection{Dispersione e forme dei pacchetti d'onda}


\begin{figure}[ht]
	\centering
	\begin{subfigure}[b]{0.4\textwidth}
		\centering
		\includegraphics[width=\textwidth]{IMG/dispersione_0}
	\end{subfigure}\\
\foreach \x in {1,3,7,10}{
\begin{subfigure}[b]{0.4\textwidth}
\centering
\includegraphics[width=\textwidth]{IMG/dispersione_\x}
\end{subfigure}
\ifthenelse{\equal{\x}{3}}{\\}{~} 
}
\caption{La dispersione delle gaussiana a $\sigma =1$}\label{fig:dispersione}
\end{figure}

La prima cosa che si pu\`o osservare nelle simulazioni (e in particolare in \autoref{fig:dispersione}) \`e la dispersione dell'onda, ovvero il pacchetto si allarga nel tempo. Questa \`e una caratteristica dell'equazione di \Schrodinger.
Per ottenere la soluzione dell'equazione con condizioni iniziali $\psi\lrt{x,0}=e^{-\frac{x^2}{2\sigma^2}}$ si passa dalla trasformata di Fourier spaziale $\hat\psi\lrt{x,0}=\sqrt{2\pi\sigma^2} e^{-\frac{k^2 \sigma^2}2}$, che porta ad avere la funzione, con dipendenza temporale:

\begin{equation}
\hat{\psi}\lrt{k,t} = \sqrt{2\pi\sigma^2} e^{-\frac{k^2 \sigma^2}2} e^{-i\frac E\hbar t} =
\sqrt{2\pi\sigma^2} e^{-\frac{k^2 \sigma^2}2} e^{-i\frac {\hbar^2 k^2/2m}\hbar t} = 
\sqrt{2\pi\sigma^2} e^{-k^2\frac{\lrt{\sigma^2+i\hbar t/m}}2 }
\end{equation}
e poi ritrasformando:
\begin{equation}
\psi\lrt{x,t} = \frac{\sigma}{\sqrt{\sigma^2 + i\hbar t /m}}
e^{-\frac{k^2}{2\lrt{\sigma + i\hbar t/m}}}
\end{equation}
quelle che rappresento sono i valori assoluti della funzione:
\begin{equation}
\lr||{\psi\lrt{x,t}} = \frac{\sigma}{\sqrt[4]{\sigma^4 + \lrt{\hbar t /m}^2}}
e^{-\frac{k^2}2\frac{\sigma^2}{\sigma^4 + \lrt{\hbar t /m}^2}} = \sqrt{\frac{\sigma_0}{\sigma(t)}}e^{-\frac{k^2}{2\sigma^2(t)}}
\end{equation}

E, chiamando $\sigma_0$ il valore assegnato nelle condizioni iniziali, mi aspetto dalla simulazione che $\sigma$ evolva come
\begin{equation}\label{eq:sigmat}
\sigma(t) = \sqrt{\frac{\sigma_0^4+\lrt{\frac\hbar m t}^2}{\sigma_0^2}}
\end{equation}

Ho fatto diversi fit, sul parametro $\sigma$, con diverse masse e diversi valori di $\sigma$ iniziali, utilizzando come funzione da fittare \eqref{eq:sigmat}. E l'algoritmo sembra funzionare per quanto riguarda la dispersione,  come si pu\`o vede re in \autoref{fig:dispersioneFitSigma1}, in
\autoref{fig:dispersioneFitSigma4} e \autoref{fig:dispersioneFitE} in dove la funzione ha energia diversa da 0

\begin{figure}[ht]
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
	\includegraphics[width=\linewidth]{IMG/dispersione_p}
	\caption{$\sigma_0=1$, $m=1$}
	\end{subfigure}
		~
\begin{subfigure}[b]{0.3\textwidth}
		\includegraphics[width=\linewidth]{IMG/dispersione_m10}
		\caption{$\sigma_0=1$, $m=10$}
 \end{subfigure}
 ~
 \begin{subfigure}[b]{0.3\textwidth}
 	\includegraphics[width=\linewidth]{IMG/dispersione_m2}
 	\caption{$\sigma_0=1$, $m=2$}
 \end{subfigure}
 \caption{Alcuni fit dell'andamento della dispersione}\label{fig:dispersioneFitSigma1}
\end{figure}

\begin{figure}[ht]
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\includegraphics[width=\linewidth]{IMG/dispersione_m1s4}
		\caption{$\sigma_0=4$, $m=1$}
	\end{subfigure}
	~
	\begin{subfigure}[b]{0.3\textwidth}
		\includegraphics[width=\linewidth]{IMG/dispersione_m10s4}
		\caption{$\sigma_0=4$, $m=10$}
	\end{subfigure}
	~
	\begin{subfigure}[b]{0.3\textwidth}
		\includegraphics[width=\linewidth]{IMG/dispersione_m2s4}
		\caption{$\sigma_0=4$, $m=10$}
	\end{subfigure}
	\caption{Alcuni fit dell'andamento della dispersione}\label{fig:dispersioneFitSigma4}
\end{figure}

\begin{figure}[ht]
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\includegraphics[width=\linewidth]{IMG/dispersione_m1s1e10}
		\caption{$\sigma_0=1$, $m=1$, con $E=10$}
	\end{subfigure}
	~
	\begin{subfigure}[b]{0.3\textwidth}
		\includegraphics[width=\linewidth]{IMG/dispersione_m1s2e10}
		\caption{$\sigma_0=2$, $m=1$, con $E=10$}
	\end{subfigure}
	~
	\begin{subfigure}[b]{0.3\textwidth}
		\includegraphics[width=\linewidth]{IMG/dispersione_m1s1e10}
		\caption{$\sigma_0=4$, $m=1$, con $E=10$}
	\end{subfigure}
	\caption{Alcuni fit dell'andamento della dispersione}\label{fig:dispersioneFitE}
\end{figure}

\begin{table}
	\centering
\begin{tabular}{cccc|cccc}
	\toprule
	t	&$\alpha$	&$\bar x$& $\sigma$ &	t	&	$\alpha$	&$\bar x$& $\sigma$\\ \toprule
	0   & 1        & 40 & 1       & 5.5 & 0.422955 & 40 & 5.59001 \\ \midrule
	0.5 & 0.94574  & 40 & 1.11803 & 6   & 0.405467 & 40 & 6.08259 \\ \midrule
	1   & 0.840898 & 40 & 1.4142  & 6.5 & 0.389951 & 40 & 6.57628 \\ \midrule
	1.5 & 0.744796 & 40 & 1.80272 & 7   & 0.376066 & 40 & 7.07086 \\ \midrule
	2   & 0.668766 & 40 & 2.23596 & 7.5 & 0.363549 & 40 & 7.56615 \\ \midrule
	2.5 & 0.609451 & 40 & 2.69242 & 8   & 0.352191 & 40 & 8.06202 \\ \midrule
	3   & 0.562349 & 40 & 3.16219 & 8.5 & 0.341825 & 40 & 8.55837 \\ \midrule
	3.5 & 0.524146 & 40 & 3.63995 & 9   & 0.332317 & 40 & 9.05512 \\ \midrule
	4   & 0.492486 & 40 & 4.12299 & 9.5 & 0.323555 & 40 & 9.55221 \\ \midrule
	4.5 & 0.465765 & 40 & 4.60964 & 10  & 0.315447 & 40 & 10.0496 \\ \midrule
	5   & 0.442856 & 40 & 5.09887 &     &          &    &         \\ \bottomrule
\end{tabular}
\caption{I dati di una simulazione, con $\alpha = 1$, $\sigma=1$ e $m=1$ }\label{table:dispersioneg1}
\end{table}

\subsection{Condizioni iniziali}
A questo punto provo anche a utilizzare la funzione ''bump'' come condizioni iniziale:
\begin{equation}
bump\lrt{x} = \lr\{.{\begin{array}{lr}
e^{-\frac{1}{1-x^2}}&\text{per }\lr||{x}<1\\
0&\text{altrove}
\end{array}}
\end{equation}

\begin{figure}
	\centering
\begin{tikzpicture}
\draw[->] (-2,0) -- (2,0) node[right] {$x$};
\draw[->] (0,-0.2) -- (0,1) node[above] {$y$};
\draw[domain=-2:2, samples =501,variable=\x,blue] plot[id=bump] function{x*x<1? exp(-1/(1-x*x)) :0};
\end{tikzpicture}
	\caption{La funzione bump}
\end{figure}

In particolare io ho usato:
\begin{equation}\label{eq:mybump}
bump = \lrt{x} = \lr\{.{\begin{array}{lr}
	e^{-\frac{b^2}{b^2-\lrt{x-a}^2}}&\text{per }\lr||{x-a}<b\\
	0&\text{altrove}
	\end{array}}
\end{equation}

simulazione
\subsection{Dispersione}
teoria

%pacchetti di Airy non disperdono-> provare

simulazione
\subsection{Potenziali}
teoria

simulazione